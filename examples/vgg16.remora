;; ---------------------------- UTILITIES ---------------------------------------------
;; @s is the shape of the array, l is length of index
;;(define (indices-of{| @s l}) : [int @s l])
;; (define (indices-of/2{| d1 d2}): [int d1 d2 2]
;;   (let [d1-val (reify-dimension d2)]
;;     ((fn ([id [int]]) [(/ id d1-val) (% id d1-val)]) iota{| [d1 d2]})))
(define (indices-of/2{| d1 d2}) : [int d1 d2 2]
  ((fn ([id1 [int]]) ((fn ([id2 [int]]) [id1 id2]) iota{|[d2]})) iota{|[d1]}))

;; (define (foo {t @t2 t3} {d1 d2 @s}
;;              ([arr [t d1 @s]] [bar [@t2 d1 d2]] -> [t3 d2 @s])) ...)

(define (indices-of/4{| d1 d2 d3 d4}): [int d1 d2 d3 d4 4]
  (let [d1-val (reify-dimension d1)]
    (let [d2-val (reify-dimension d2)]
      (let [d3-val (reify-dimension d3)]
        (let [d4-val (reify-dimension d4)]
          ((fn ([id [int]])
             (let [id1 (/ id (* d2-val (* d3-val d4-val)))]
               (let [id2 (% id (* d2-val (* d3-val d4-val)))]
                 (let [id3 (% id (* d3-val d4-val))]
                   [id1
                    (/ id2 (* d3-val d4-val))
                    (/ id3 d4-val)
                    (% id3 d4-val)]))))
           iota{| [d1 d2 d3 d4]}))))))

(define (subarray/2{t | in1 in2 out1 out2} [arr [t in1 in2]] [offset [int 2]]) : [t out1 out2]
  (index{t | [in1 in2] [] 2} arr (+ (indices-of/2{| out1 out2}) 
                                    (replicate{int | [out1 out2] [2]} offset))))

(define (index-in-range?{| l-1} [idx [int (+ l-1 1)]] [top [int (+ l-1 1)]]) : [bool]
  (reduce{bool | l-1 [] []} and (and (>= idx 0) (< idx top))))

;; FIXME: this is totally broken as it either abuses the conditional execution of if
;; (as it is not enforced right now), or that index out of bounds just gives a bogus value
;; both are bad but this should be a builtin function
(define (subarray-fill/2{t | in1 in2 out1 out2}
          [arr [t in1 in2]]
          [offset [int 2]]
          [fill [t]]) : [t out1 out2]
  (define top [(reify-dimension in1) (reify-dimension in2)])
  (define (cond-index [idx [int 2]]) : [t]
    (if{t | }
        (index-in-range?{| 1} idx top)
        (index{t | [in1 in2] [] 2} arr idx)
        fill))
  (cond-index (+ (indices-of/2{| out1 out2}) (replicate{int | [out1 out2] [2]} offset))))

;; Preconditions:
;; 1. axis is a permutations of numbers [0,4), no duplicates
(define (transpose/4{t | in1 in2 in3 in4 out1 out2 out3 out4}
          [arr [t in1 in2 in3 in4]]
          [axis [int 4]])
  (define idxs (indices-of/4{| in1 in2 in3 in4}))
  (define transposed-idxs (scatter{int | 4 4 []} idxs axis))
  (index{t | [in1 in2 in3 in4] [] 4} arr transposed-idxs))

(define (flatten/4{t | in1 in2 in3 in4 out1 out2} [arr [t in1 in2 in3 in4]]) : [t out1 out2]
  (reshape [out1 out2] (transpose/4{t | in1 in2 in3 in4 in1 in3 in2 in4 } arr [0 2 1 3])))

;; Mirrors along all axis, kinda hack before we have stdlib mirror
(define (full-mirror/2{t | n} [arr [t n n]]) : [t n n]
  (index{t| [n n] [] 2} arr (- (reify-dimension n) (+ 1 (indices-of/2{| n n})))))

;; Syntax idea:
;; (define (pad/2{}{n pad}))
;; (pad/2{}{5 1})

;; (define (pad/2{t | n pad} (arr : [t n n]) [fill : t])) ->
(define (pad/2{t | n pad} [arr [t n n]] [fill [t]]) : [t (+ n pad pad) (+ n pad pad)]
  (define pad-val (reify-dimension pad))
  (subarray-fill/2{t | n n (+ n pad pad) (+ n pad pad)} arr [(- 0 pad-val) (- 0 pad-val)] fill))

;; ---------------------------- CONVOLUTION ---------------------------------------------
;; Matrix point-wise float add
(define (matrix-+.{ | m n} [a [float m n]] [b [float m n]])
  (+. a b))

(define (conv-2d{| n-1 k-1 o stride pad}
                              [data [float (+ n-1 1) (+ n-1 1)]]
                              [weights [float (+ k-1 1) (+ k-1 1)]]
                              [bias [float]]) : [float o o]
  (let [padded-data (pad/2{float | (+ n-1 1) pad} data 0.0)]
  (let [windows (subarray/2{float | (+ 1 n-1 pad pad) (+ 1 n-1 pad pad) (+ 1 k-1) (+ 1 k-1)}
                           padded-data (* (reify-dimension stride) (indices-of/2{| o o})))]
    (let [repl-weights (replicate{float | [o o] [(+ k-1 1) (+ k-1 1)]} weights)]
    ;; TODO: reshape is wrong, we need multiply that we cannot replace with add
    (+. bias (reduce{float | k-1 [] []} +. (reduce{float | k-1 [] []} +. (*. windows repl-weights))))))))
      ;; (+. bias (reduce{float | (+ k-1 k-1 k-1 1 1) [] []} +. (reshape [o o (+ k-1 k-1 k-1 1 1 1)] (*. windows repl-weights))))))))

;; we need convolution 3d for channels in 2d image
(define (conv-2d-channel{| n-1 k-1 c-1 o stride pad}
          [data [float (+ c-1 1) (+ n-1 1) (+ n-1 1)]]
          [weights [float (+ c-1 1) (+ k-1 1) (+ k-1 1)]]
          [bias [float]]) : [float o o]
  (reduce{float | c-1 [] [o o]}
    matrix-+.{ | o o}
    (conv-2d{| n-1 k-1 o stride pad} data weights bias)))

(define (conv-2d-back{| n-1 k-2 o-1 stride o*stride o_dil-1} [data [float (+ 1 n-1) (+ 1 n-1)]]
                                                  [weights [float (+ 2 k-2) (+ 2 k-2)]]
                                                  [dout [float (+ 1 o-1) (+ 1 o-1)]])
  (define dout_dil (subarray/2{float | o*stride o*stride (+ o_dil-1 1) (+ o_dil-1 1)}
    (flatten/4{float | (+ o-1 1) (+ o-1 1) stride stride o*stride o*stride}
      (subarray-fill/2{float | 1 1 stride stride} (reshape [(+ o-1 1) (+ o-1 1) 1 1] dout)
                                                  [0 0]
                                                  0.0))
    [0 0]))
  (define dout_dil_pad (pad/2{float | (+ o_dil-1 1) (+ k-2 1)} dout_dil 0.0))
  (define weights_mirror (full-mirror/2{float | (+ k-2 2)} weights))
  (define dw (conv-2d{| n-1 o_dil-1 (+ k-2 2) 1 0} data dout_dil 0.0))
  (define din (conv-2d{| (+ o_dil-1 1 k-2 k-2 1) (+ k-2 1) (+ n-1 1) 1 0} dout_dil_pad weights_mirror 0.0))
  (define db (reduce{float | (+ o-1 1 o-1) [] []} +. (reshape [(+ o-1 1 o-1 1)] dout)))
  (tuple (box () [float (+ k-2 2) (+ k-2 2)] dw)
         (box () [float (+ n-1 1) (+ n-1 1)] din)
         (box () [float] db)))

(define (conv-2d-back-channel{| n-1 k-2 c-1 o-1 stride o*stride o_dil-1}
          [data [float (+ c-1 1) (+ n-1 1) (+ n-1 1)]]
          [weights [float (+ c-1 1) (+ k-2 2) (+ k-2 2)]]
          [dout [float (+ o-1 1) (+ o-1 1)]])
  ;;
  (define res (conv-2d-back{| n-1 k-2 o-1 stride o*stride o_dil-1}
                data weights (/. dout (int->float (reify-dimension (+ c-1 1))))))
  (define dw (unbox (#0 res) (dw_unboxed) dw_unboxed))
  (define din (unbox (#1 res) (din_unboxed) din_unboxed))
  (define db_vec (unbox (#2 res) (db_unboxed) db_unboxed))
  (define db (reduce{float | c-1 [] []} +. db_vec))
  ;; Not sure why this doesn't work, will check later
  ;; (define db (unbox (#2 res) (db_unboxed) (reduce{float | c-1 [] []} +. db_unboxed)))
  ;; TODO: this is so incredibly verbose
  (tuple (box () [float (+ c-1 1) (+ k-2 2) (+ k-2 2)] dw)
         (box () [float (+ c-1 1) (+ n-1 1) (+ n-1 1)] din)
         (box () [float] db)))

;; ---------------------------- FULLY CONNECTED ---------------------------------------------
(define (fc-2d-fwd{| in-1 out-1} [input [float (+ in-1 1)]]
                                 [weights [float (+ out-1 1) (+ in-1 1)]]
                                 [bias [float (+ out-1 1)]]) : [float (+ out-1 1)]
  (+. bias
    (reduce{float | in-1 [] []}
      +.
      (*. (replicate{float | [(+ out-1 1)] [(+ in-1 1)]} input)
          weights))))

(define (fc-2d-back{| in-1 o-1}
          [in [float (+ in-1 1)]]
          [w  [float (+ o-1 1) (+ in-1 1)]]
          [dout [float (+ o-1 1)]])
  (define din
    (reduce{float | o-1 [] [(+ in-1 1)] }
      (fn ([a [float (+ in-1 1)]]
           [b [float (+ in-1 1)]]) : [float (+ in-1 1)]
        (+. a b))
      (*. dout w)))
  (define dw (*. (replicate{float | [(+ in-1 1)] []} dout)
                 (replicate{float | [(+ o-1 1)] [(+ in-1 1)]} in)))
  ;; (define db (reduce{float | o-1 [] []} +. dout))
  (tuple (box () [float (+ in-1 1)] din)
         (box () [float (+ o-1 1) (+ in-1 1)] dw)
         ;; it's just the dout vector
         (box () [float (+ o-1 1)] dout)))


;; ---------------------------- [MAX] POOLING ---------------------------------------------
(define (max2. [a [float]] [b [float]]) : [float]
  (select{float | } (>. a b) a b))

(define (min2. [a [float]] [b [float]])
  (select{float | } (<. a b) a b))

(define (max-pool-2d{| n-1 pool-size-1 stride out} [data [float (+ 1 n-1) (+ n-1 1)]]) ;: [float out out]
  (define windows (subarray/2{float | (+ 1 n-1) (+ 1 n-1) (+ 1 pool-size-1) (+ 1 pool-size-1) }
                    data
                    (* (reify-dimension stride) (indices-of/2{| out out}))))
  (define max-per-pool (reduce{float | (+ pool-size-1 pool-size-1 1) [] []}
                         max2.
                         (reshape [out out (+ pool-size-1 1 pool-size-1 1)] windows)))
  max-per-pool)

(define (max-pool-back{| n-1 pool-size-1 out stride}
                          [in [float (+ n-1 1) (+ n-1 1)]]
                          [max-per-pool [float out out]]
                          [dout [float out out]]) ;: [float in in]
  (define windows (subarray/2{float | (+ 1 n-1) (+ 1 n-1) (+ 1 pool-size-1) (+ 1 pool-size-1) }
                     in
                     (* (reify-dimension stride) (indices-of/2{| out out}))))
  (define mask ((fn ([win [float (+ 1 pool-size-1) (+ 1 pool-size-1)]]
                     [max-val [float]])
                   (select{float | } (=. win max-val) 1.0 0.0))
                 windows
                 max-per-pool))
  (define max-count-per-pool (reduce{float | (+ pool-size-1 pool-size-1 1) [] []}
                                +.
                                (reshape [out out (+ pool-size-1 1 pool-size-1 1)] mask)))
  (define weighted-max ((fn ([m [float (+ pool-size-1 1) (+ pool-size-1 1)]]
                             [count [float]]
                             [dout-val [float]])
                          (*. dout-val (/. m count)))
                        mask
                        max-count-per-pool
                        dout))
  (flatten/4{float | out out (+ pool-size-1 1) (+ pool-size-1 1) (+ n-1 1) (+ n-1 1)} weighted-max))


;; ---------------------------- ACTIVATIONS ---------------------------------------------

(define (leaky-relu [x [float]]) : float
  (select{float |} (>. x 0.0) x (*. 0.1 x)))

(define (leaky-relu-prime [x [float]]) : float
  (select{float |} (>. x 0.0) 1.0 0.1))

(define (relu [x [float]]) : float
  (select{float |} (>. x 0.0) x 0.0))

(define (relu-prime [x [float]]) : float
  (select{float |} (>. x 0.0) 1.0 0.0))

(define (linear [x [float]]) : float
  x)

(define (linear-prime [x [float]]) : float
  1.0)

(define (softmax{| in-1} [x [float (+ 1 in-1)]]) : [float (+ 1 in-1)]
  (let [e (exp x)]
    (/. e (reduce{float | in-1 [] []} +. e))))

; truth is one-hot encoding vector - there can only be 1 1.0 value, everything else is 0.0
; x is the output of softmax function
(define (softmax-prime{| in} [x [float in]] [truth [float in]]) : [float in]
  (-. x truth))

; turns softmax output vector to one-hot encoded vector -
; max value turns into 1, all others into 0
(define (softmax->class-vector{| in-1} [e [float (+ 1 in-1)]]): [float (+ 1 in-1)]
  (let [max-val (reduce{float | in-1 [] []} max2. e)]
    (if{float|} (=. e max-val) 1.0 0.0)))
    ;; ((fn ([v [float]] (select (=. v max-val) 1.0 0.0))) e)))


;; ---------------------------- FLATTEN (?) ---------------------------------------------
;; Flatten layers are to feed data into fully connected layers 
;; (since they require 1D input no matter what kind of data is pr;cessed)
(define (flatten-2d-fwd{| @in out} [input [float @in]]) : [float out]
  (reshape [out] input))

(define (flatten-2d-bwd{| @in out} [dy [float out]]) : [float @in]
  (reshape [@in] dy))


;; ----------------------------------------- MAIN -------------------------------------------
;; VGG-16

(define (full-conv-process{| out-ch in-ch-1 n-1 k-1 o stride pad}
         [input [float (+ in-ch-1 1) (+ n-1 1) (+ n-1 1)]]) : [float out-ch o o]
  (define weights (int->float iota{| [out-ch (+ in-ch-1 1) (+ k-1 1) (+ k-1 1)]}))
  (define out_conv (conv-2d-channel{| n-1 k-1 in-ch-1 o stride pad} input weights 0.0))
  (define out (relu out_conv))
  out)

; (define input (int->float iota{| [50 50]}))
; (define weights (int->float iota{| [1 3 3]}))
; (define out_conv (conv-2d{| 49 2 50 1 1} input weights 0.0))
;(indices-of/2{| 50 50})
;(define out (relu out_conv))
(define input (int->float iota{| [3 224 224]}))
;; Block 1
(define out1 (full-conv-process{| 64 2 223 2 224 1 1} input))
;; (define weights (int->float iota{|[1 3 3 3]}))
;; (define out1 (conv-2d-channel{| 223 2 2 1 1 0} input weights 0.0))
out1
;; (define out2 (full-conv-process{| 64 63 223 2 224 1 1} out1))
;; (define out3 (max-pool-2d{| 223 1 2 112} out2))
;; out3
;; Block 2
;; (define out4 (full-conv-process{| 128 63 111 2 112 1 1} out3))
;; (define out5 (full-conv-process{| 128 127 111 2 112 1 1} out4))
;; (define out6 (max-pool-2d{| 111 1 2 56} out5))
;; out6
;; Block 3
;; (define out7 (full-conv-process{| 256 127 55 2 56 1 1} out6))
;; (define out8 (full-conv-process{| 256 255 55 2 56 1 1} out7))
;; (define out9 (full-conv-process{| 256 255 55 2 56 1 1} out8))
;; (define out10 (max-pool-2d{| 55 1 2 28} out9))
;; ;; Block 4
;; (define out11 (full-conv-process{| 512 255 27 2 28 1 1} out10))
;; (define out12 (full-conv-process{| 512 511 27 2 28 1 1} out11))
;; (define out13 (full-conv-process{| 512 511 27 2 28 1 1} out12))
;; (define out14 (max-pool-2d{| 27 1 2 14} out13))
;; ;; Block 5
;; (define out15 (full-conv-process{| 512 511 13 2 14 1 1} out14))
;; (define out16 (full-conv-process{| 512 511 13 2 14 1 1} out15))
;; (define out17 (full-conv-process{| 512 511 13 2 14 1 1} out16))
;; (define out18 (max-pool-2d{| 13 1 2 7} out17))
;; out18
;; ;; Flatten
;; (define out19 (flatten-2d-fwd{| [512 7 7] 25088} out18))
;; ;; FC 1
;; (define w20 (int->float iota{| [4096 25088]}))
;; (define b20 (replicate{float| [4096] []} 0.0))
;; (define out20_fc (fc-2d-fwd{| 25087 4095} out19 w20 b20))
;; (define out20 (relu out20_fc))
;; ;; FC 2
;; (define w21 (int->float iota{| [4096 4096]}))
;; (define b21 (replicate{float| [4096] []} 0.0))
;; (define out21_fc (fc-2d-fwd{| 4095 4095} out20 w21 b21))
;; (define out21 (relu out21_fc))
;; ;; FC 3
;; (define w22 (int->float iota{| [1000 4096]}))
;; (define b22 (replicate{float| [1000] []} 0.0))
;; (define out22_fc (fc-2d-fwd{| 4095 999} out21 w22 b22))
;; (define out22 (softmax{| 999} out22_fc))

;; out22
