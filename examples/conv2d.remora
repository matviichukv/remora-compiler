;; ---------------------------- UTILITIES ---------------------------------------------
;; @s is the shape of the array, l is length of index
;;(define (indices-of{| @s l}) : [int @s l])
(define (indices-of/2{| d1 d2}): [int d1 d2 2]
  (let [d1-val (reify-dimension d1)]
    ((fn ([id [int]]) [(/ id d1-val) (% id d1-val)]) iota{| [d1 d2]})))

(define (indices-of/4{| d1 d2 d3 d4}): [int d1 d2 d3 d4 4]
  (let [d1-val (reify-dimension d1)]
    (let [d2-val (reify-dimension d2)]
      (let [d3-val (reify-dimension d3)]
        (let [d4-val (reify-dimension d4)]
          ((fn ([id [int]])
             (let [id1 (/ id (* d2-val (* d3-val d4-val)))]
               (let [id2 (% id (* d2-val (* d3-val d4-val)))]
                 (let [id3 (% id (* d3-val d4-val))]
                   [id1
                    (/ id2 (* d3-val d4-val))
                    (/ id3 d4-val)
                    (% id3 d4-val)]))))
           iota{| [d1 d2 d3 d4]}))))))

(define (subarray/2{t | in1 in2 out1 out2} [arr [t in1 in2]] [offset [int 2]])
  (index{t | [in1 in2] [] 2} arr (+ (indices-of/2{| out1 out2}) 
                                    (replicate{int | [out1 out2] [2]} offset))))

(define (index-in-range?{| l-1} [idx [int (+ l-1 1)]] [top [int (+ l-1 1)]]) : [bool]
  (define zeroes ((fn ([_ [int]]) 0) iota{| [(+ l-1 1)]}))
  (reduce{bool | l-1 [] []} and (and (>= idx zeroes) (< idx top))))

;; FIXME: this is totally broken as it either abuses the conditional execution of if
;; (as it is not enforced right now), or that index out of bounds just gives a bogus value
;; both are bad but this should be a builtin function
(define (subarray-fill/2{t | in1 in2 out1 out2}
          [arr [t in1 in2]]
          [offset [int 2]]
          [fill [t]]) : [t out1 out2]
  (define top [(reify-dimension in1) (reify-dimension in2)])
  (define (cond-index [idx [int 2]]) : [t]
    (if{t | }
        (index-in-range?{| 1} idx top)
        (index{t | [in1 in2] [] 2} arr idx)
        fill))
  (cond-index (+ (indices-of/2{| out1 out2}) (replicate{int | [out1 out2] [2]} offset))))

;; Preconditions:
;; 1. axis is a permutations of numbers [0,4), no duplicates
(define (transpose/4{t | in1 in2 in3 in4 out1 out2 out3 out4}
          [arr [t in1 in2 in3 in4]]
          [axis [int 4]])
  (define idxs (indices-of/4{| in1 in2 in3 in4}))
  (define transposed-idxs (scatter{int | 4 4 []} idxs axis))
  (index{t | [in1 in2 in3 in4] [] 4} arr transposed-idxs))

(define (flatten/4{t | in1 in2 in3 in4 out1 out2} [arr [t in1 in2 in3 in4]]) : [t out1 out2]
  (reshape [out1 out2] (transpose/4{t | in1 in2 in3 in4 in1 in3 in2 in4 } arr [0 2 1 3])))

;; Mirrors along all axis, kinda hack before we have stdlib mirror
(define (full-mirror/2{t | n} [arr [t n n]]) : [t n n]
  (index{t| [n n] [] 2} arr (- (reify-dimension n) (+ 1 (indices-of/2{| n n})))))

;; Syntax idea:
;; (define (pad/2{}{n pad}))
;; (pad/2{}{5 1})

;; (define (pad/2{t | n pad} (arr : [t n n]) [fill : t])) ->
(define (pad/2{t | n pad} [arr [t n n]] [fill [t]]) : [t (+ n pad pad) (+ n pad pad)]
  (define pad-val (reify-dimension pad))
  (subarray-fill/2{t | n n (+ n pad pad) (+ n pad pad)} arr [(- 0 pad-val) (- 0 pad-val)] fill))

;; ---------------------------- CONVOLUTION ---------------------------------------------
;; Matrix point-wise float add
(define (matrix-+.{ | m n} [a [float m n]] [b [float m n]])
  (+. a b))

(define (conv-2d{| n-1 k-1 o stride pad}
                              [data [float (+ n-1 1) (+ n-1 1)]]
                              [weights [float (+ k-1 1) (+ k-1 1)]]
                              [bias [float]]) : [float o o]
  (let [windows (subarray/2{float | (+ 1 n-1) (+ 1 n-1) (+ 1 k-1) (+ 1 k-1)}
                           data (* (reify-dimension stride) (indices-of/2{| o o})))]
    (let [repl-weights (replicate{float | [o o] [(+ k-1 1) (+ k-1 1)]} weights)]
      (+. bias (reduce{float | k-1 [] []} +. (reduce{float | k-1 [] []} +. (*. windows repl-weights)))))))

;; we need convolution 3d for channels in 2d image
(define (conv-2d-channel{| n-1 k-1 c-1 o stride pad}
          [data [float (+ c-1 1) (+ n-1 1) (+ n-1 1)]]
          [weights [float (+ c-1 1) (+ k-1 1) (+ k-1 1)]]
          [bias [float]]) : [float o o]
  (reduce{float | c-1 [] [o o]}
    matrix-+.{ | o o}
    (conv-2d{| n-1 k-1 o stride pad} data weights bias)))

(define (conv-2d-back{| n-1 k-2 o-1 stride o*stride o_dil-1} [data [float (+ 1 n-1) (+ 1 n-1)]]
                                                  [weights [float (+ 2 k-2) (+ 2 k-2)]]
                                                  [dout [float (+ 1 o-1) (+ 1 o-1)]])
  (define dout_dil (subarray/2{float | o*stride o*stride (+ o_dil-1 1) (+ o_dil-1 1)}
    (flatten/4{float | (+ o-1 1) (+ o-1 1) stride stride o*stride o*stride}
      (subarray-fill/2{float | 1 1 stride stride} (reshape [(+ o-1 1) (+ o-1 1) 1 1] dout)
                                                  [0 0]
                                                  0.0))
    [0 0]))
  (define dout_dil_pad (pad/2{float | (+ o_dil-1 1) (+ k-2 1)} dout_dil 0.0))
  (define weights_mirror (full-mirror/2{float | (+ k-2 2)} weights))
  (define dw (conv-2d{| n-1 o_dil-1 (+ k-2 2) 1 0} data dout_dil 0.0))
  (define din (conv-2d{| (+ o_dil-1 1 k-2 k-2 1) (+ k-2 1) (+ n-1 1) 1 0} dout_dil_pad weights_mirror 0.0))
  (define db (reduce{float | o-1 [] []} +. (reduce{float | o-1 [] []} +. dout)))
  (values (box () [float (+ k-2 2) (+ k-2 2)] dw) 
          (box () [float (+ n-1 1) (+ n-1 1)] din)
          (box () [float] db)))

(define (conv-2d-back-channel{| n-1 k-2 c-1 o-1 stride o*stride o_dil-1}
          [data [float (+ c-1 1) (+ n-1 1) (+ n-1 1)]]
          [weights [float (+ c-1 1) (+ k-2 2) (+ k-2 2)]]
          [dout [float (+ o-1 1) (+ o-1 1)]])
  ;;
  (define res (conv-2d-back{| n-1 k-2 o-1 stride o*stride o_dil-1}
                data weights (/. dout (int->float (reify-dimension (+ c-1 1))))))
  (define dw (unbox (#0 res) (dw_unboxed) dw_unboxed))
  (define din (unbox (#1 res) (din_unboxed) din_unboxed))
  (define db_vec (unbox (#2 res) (db_unboxed) db_unboxed))
  (define db (reduce{float | c-1 [] []} +. db_vec))
  ;; Not sure why this doesn't work, will check later
  ;; (define db (unbox (#2 res) (db_unboxed) (reduce{float | c-1 [] []} +. db_unboxed)))
  ;; TODO: this is so incredibly verbose
  (values (box () [float (+ c-1 1) (+ k-2 2) (+ k-2 2)] dw)
          (box () [float (+ c-1 1) (+ n-1 1) (+ n-1 1)] din)
          (box () [float] db)))

;; ---------------------------- FULLY CONNECTED ---------------------------------------------
(define (fc-2d-fwd{| in-1 out-1} [input [float (+ in-1 1)]]
                                 [weights [float (+ out-1 1) (+ in-1 1)]]
                                 [bias [float (+ out-1 1)]]) : [float (+ out-1 1)]
  (+. bias
    (reduce{float | in-1 [] []}
      +.
      (*. (replicate{float | [(+ out-1 1)] [(+ in-1 1)]} input)
          weights))))

(define (fc-2d-back{| in-1 o-1}
          [in [float (+ in-1 1)]]
          [w  [float (+ o-1 1) (+ in-1 1)]]
          [dout [float (+ o-1 1)]])
  (define din
    (reduce{float | o-1 [] [(+ in-1 1)] }
      (fn ([a [float (+ in-1 1)]]
           [b [float (+ in-1 1)]]) : [float (+ in-1 1)]
        (+. a b))
      (*. dout w)))
  (define dw (*. (replicate{float | [(+ in-1 1)] []} dout)
                 (replicate{float | [(+ o-1 1)] [(+ in-1 1)]} in)))
  ;; (define db (reduce{float | o-1 [] []} +. dout))
  (values (box () [float (+ in-1 1)] din)
          (box () [float (+ o-1 1) (+ in-1 1)] dw)
          ;; it's just the dout vector
          (box () [float (+ o-1 1)] dout)))


;;(conv1d{| 4 2 3} [1.0 2.0 3.0 4.0 5.0] [[0.5 1.0 1.5] [1.0 1.0 1.0]])
;;(fc-2d{| 2 1} [1.0 2.0 3.0] [[1.0 2.0 3.0] [0.1 0.2 0.3]] [0.5 0.3])

;; ---------------------------- [MAX] POOLING ---------------------------------------------
(define (max2. [a [float]] [b [float]]) : [float]
  (select{float | } (>. a b) a b))

(define (min2. [a [float]] [b [float]])
  (select{float | } (<. a b) a b))

(define (max-pool-2d{| n-1 pool-size-1 stride out} [data [float (+ 1 n-1) (+ n-1 1)]]) ;: [float out out]
  (define windows (subarray/2{float | (+ 1 n-1) (+ 1 n-1) (+ 1 pool-size-1) (+ 1 pool-size-1) } data (* (reify-dimension stride) (indices-of/2{| out out}))))
  (define max-per-pool (reduce{float | pool-size-1 [] []} max2. (reduce{float | pool-size-1 [] []} max2. windows)))
  max-per-pool)

(define (max-pool-back{| n-1 pool-size-1 out stride}
                          [in [float (+ n-1 1) (+ n-1 1)]]
                          [max-per-pool [float out out]]
                          [dout [float out out]]) ;: [float in in]
  (define windows (subarray/2{float | (+ 1 n-1) (+ 1 n-1) (+ 1 pool-size-1) (+ 1 pool-size-1) } in (* (reify-dimension stride) (indices-of/2{| out out}))))
  (define mask ((fn ([win [float (+ 1 pool-size-1) (+ 1 pool-size-1)]]
                     [max-val [float]])
                   (select{float | } (=. win max-val) 1.0 0.0))
                 windows
                 max-per-pool))
  (define max-count-per-pool (reduce{float | pool-size-1 [] []} +. (reduce{float | pool-size-1 [] []} +. mask)))
  (define weighted-max ((fn ([m [float (+ pool-size-1 1) (+ pool-size-1 1)]]
                             [count [float]]
                             [dout-val [float]])
                          (*. dout-val (/. m count)))
                        mask
                        max-count-per-pool
                        dout))
  (flatten/4{float | out out (+ pool-size-1 1) (+ pool-size-1 1) (+ n-1 1) (+ n-1 1)} weighted-max))

;; ---------------------------- DROPOUT ---------------------------------------------
;; TODO: how to random
;; ---------------------------- BATCH NORMALIZATION -----------------------------------------
(define (mean{| n-1 } [input [float (+ 1 n-1) (+ 1 n-1)]])
  (define n-val (reify-dimension (+ 1 n-1)))
  (/. (reduce{float | n-1 [] [] } +. (reduce{float | n-1 [] []} +. input))
      (int->float (* n-val n-val))))

(define (variance{| n-1 } [input [float (+ 1 n-1) (+ 1 n-1)]] [mean [float]])
  (define n-val (reify-dimension (+ 1 n-1)))
  (let [diff-x (-. input mean)]
    (/. (reduce{float | n-1 [] []} +. (reduce{float | n-1 [] []} +. (*. diff-x diff-x)))
      (int->float (- (* n-val n-val) 1)))))

;; Returns 3 values: output, new rolling mean, new rolling var
(define (batch-norm-2d{ | n-1 k}
                       [input [float k (+ 1 n-1) (+ 1 n-1)]]
                       [rolling-mean [float k]]
                       [rolling-var [float k]]
                       [bias [float k]]
                       [train [bool]]) ; : [float k (+ 1 n-1) (+ 1 n-1)]
  (define input-mean (mean{| n-1} input))
  (define input-var  (variance{| n-1} input input-mean))
  (define new-rolling-mean (+. (*. 0.99 rolling-mean) (*. 0.01 input-mean)))
  (define new-rolling-var  (+. (*. 0.99 rolling-var)  (*. 0.01 input-var)))
  (define mean-to-use (select{float | } train input-mean rolling-mean))
  (define var-to-use  (select{float | } train input-var rolling-var))
  (define diff-x (-. input mean-to-use))
  (define normalized-input (/. diff-x (sqrt (+. var-to-use 0.000001))))
  (define output (+. normalized-input bias))
  (values (box () [float k (+ n-1 1) (+ n-1 1)] output)
          (box () [float k] new-rolling-mean)
          (box () [float k] new-rolling-var)))

;; Returns 4 values: delta for mean, delta for var, delta for bias, delta for input
(define (batch-norm-2d-back{| n-1 k}
                            [input [float k (+ n-1 1) (+ n-1 1)]]
                            [dout  [float k (+ n-1 1) (+ n-1 1)]]
                            [mean  [float k]]
                            [var   [float k]]
                            [rolling-mean [float k]]
                            [rolling-var  [float k]]
                            [train [bool]])
  (define n-val (reify-dimension (+ 1 n-1)))
  (define spatial (int->float (* n-val n-val)))
  (define mean-to-use (+. 0.00001 (select{float | } train mean rolling-mean)))
  (define var-to-use  (+. 0.00001 (select{float | } train var rolling-var)))
  (define db (reduce{float | n-1 [] []} +. (reduce{float | n-1 [] []} +. dout)))
  (define dmean (*. -1.0 (/. db ; we need the sum of dout, so we just reuse db
                             (sqrt var-to-use))))
  (define dvar-wip (reduce{float | n-1 [] [] } +. (reduce{float | n-1 [] []} +. (*. dout (-. input mean-to-use)))))
  (define dvar     (*. dvar-wip (*. -0.5 (expt var-to-use -1.5))))
  (define din      (+. (/. dout (sqrt var-to-use))
                       (+. (/. (*. 2.0 (*. dvar (-. input mean-to-use))) spatial)
                           (/. dmean spatial))))
  (values (box () [float k] dmean)
          (box () [float k] dvar)
          (box () [float k] db)
          (box () [float k (+ n-1 1) (+ n-1 1)] din)))
;; ---------------------------- DETECTION ---------------------------------------------

;; yolo-box - 5 long vector - [x y w h confidence]
;; TODO: ideally put them into a record

(define (yolo-box-rmse [a-full [float 5]] [b-full [float 5]]) : [float]
  (define a (subvector{float | 5 4 []} a-full 0))
  (define b (subvector{float | 5 4 []} b-full 0))
  (sqrt (reduce{float | 3 [] []} +. (expt (-. a b) 2.0))))

(define (overlap [x1 [float]] [w1 [float]] [x2 [float]] [w2 [float]]) : [float]
  (define l1 (-. x1 (/. w1 2.0)))
  (define l2 (-. x2 (/. w2 2.0)))
  (define left (max2. l1 l2))
  (define r1 (+. x1 (/. w1 2.0)))
  (define r2 (+. x2 (/. w2 2.0)))
  (define right (min2. r1 r2))
  (-. right left))

;; inputs are two yolo boxes,
(define (yolo-box-intersect [a [float 5]] [b [float 5]]) : [float]
  ;; This is a really good test for checking how well compiler optimizes this kind of code
  ;; as it similar to what is used in graphics
  (define w (overlap (index{float | [5] [] 1} a [0]) (index{float | [5] [] 1} a [2])
                     (index{float | [5] [] 1} b [0]) (index{float | [5] [] 1} b [2])))
  (define h (overlap (index{float | [5] [] 1} a [1]) (index{float | [5] [] 1} a [3])
                     (index{float | [5] [] 1} b [1]) (index{float | [5] [] 1} b [3])))
  (define area (*. w h))
  area)
  ;; (select{float |} (<. area 0.0) 0.0 area))

(define (yolo-box-area [a [float 5]])
  (*. (index{float | [5] [] 1} a [2]) (index{float | [5] [] 1} a [3])))

(define (yolo-box-union [a [float 5]] [b [float 5]]) : [float]
  (define intersect (yolo-box-intersect a b))
  (+. (yolo-box-area a)
      (+. (yolo-box-area b)
          (-. 0.0 intersect))))

(define (yolo-box-iou [a [float 5]] [b [float 5]]) : [float]
  (/. (yolo-box-intersect a b)
      (yolo-box-union a b)))

(define (best-yolo-box-delta [pred-box [float 5]]
                             [truth-box [float 5]]
                             [coord-scale [float]]
                             [obj-scale [float]]
                             [sqrt-flag [bool]]
                             [rescore-flag [bool]]) : [float 5]
  (define new-w (*. coord-scale (select{float |} sqrt-flag
                                   (-. (sqrt (index{float | [5] [] 1} truth-box [2])) (index{float | [5] [] 1} pred-box [2]))
                                   (-. (index{float | [5] [] 1} truth-box [2]) (index{float | [5] [] 1} pred-box [2])))))
  (define new-h (*. coord-scale (select{float |} sqrt-flag
                                   (-. (sqrt (index{float | [5] [] 1} truth-box [3])) (index{float | [5] [] 1} pred-box [3]))
                                   (-. (index{float | [5] [] 1} truth-box [3]) (index{float | [5] [] 1} pred-box [3])))))
  (define iou (yolo-box-iou pred-box truth-box))
  (define delta-p (select{float |} rescore-flag
                          (*. obj-scale (-. iou (index{float | [5] [] 1} pred-box [4])))
                          (*. obj-scale (-. 1.0 (index{float | [5] [] 1} pred-box [4])))))
  [(*. coord-scale (-. (index{float | [5] [] 1} truth-box [0]) (index{float | [5] [] 1} pred-box [0])))
   (*. coord-scale (-. (index{float | [5] [] 1} truth-box [1]) (index{float | [5] [] 1} pred-box [1])))
   new-w
   new-h
   delta-p])

(define (other-yolo-box-delta [pred-box [float 5]] [noobj-scale [float]]) : [float 5]
  [0.0
   0.0
   0.0
   0.0
   (*. noobj-scale (-. 0.0 (index{float | [5] [] 1} pred-box [4])))])

(define (merge-box-and-class-delta{| classes-num boxes-num} [boxes [float boxes-num 5]] [class-delta [float classes-num]])
  (append{float | (+ boxes-num boxes-num boxes-num boxes-num boxes-num) classes-num []}
          (reshape [(+ boxes-num boxes-num boxes-num boxes-num boxes-num)] boxes)
          class-delta))

;; Precondition: boxes-arr-size = 5 * boxes-num
;; Precondition: n = boxes-arr-size + classes-1 + 1
(define (detection-2d{| n boxes-arr-size boxes-num-1 classes-1}
                      [input        [float n]]
                      [truth        [float n]]
                      [sqrt-flag    [bool]]
                      [rescore-flag [bool]]
                      [obj-scale    [float]]
                      [noobj-scale  [float]]
                      [coord-scale  [float]]
                      [class-scale  [float]])
  (define box-pred (reshape [(+ 1 boxes-num-1) 5] (subvector{float | n boxes-arr-size []} input 0)))
  (define class-pred (subvector{float | n (+ 1 classes-1) []} input (reify-dimension boxes-arr-size)))
  (define truth-box (subvector{float | n 5 []} truth 0))
  (define truth-classes (subvector{float | n (+ 1 classes-1) []} input 5))
  (define class-delta (*. class-scale (-. truth-classes class-pred)))
  (define class-cost (reduce{float | classes-1 [] []} +. (*. class-scale (expt (-. truth-classes class-pred) 2.0))))

  ;; acc is the stats accumulated, next is the box to compare next
  ;; returns new stats
  ;; acc = [best-idx best-iou best-rmse cur-idx]
  ;; should use tuples/records instead, cur-idx is being tracked as a float
  (define (box-cmp [acc [float 4]] [next [float 5]]) : [float 4]
     (define cur-idx (index{float | [4] [] 1} acc [3]))
     (define iou (yolo-box-iou next truth-box))
     (define rmse (yolo-box-rmse next truth-box))
     (define best-idx (index{float | [4] [] 1} acc [0]))
     (define best-iou (index{float | [4] [] 1} acc [1]))
     (define best-rmse (index{float | [4] [] 1} acc [2]))
     (select{float |} (or (>. best-iou 0.0) (>. iou 0.0))
        (select{float |} (>. iou best-iou) [cur-idx iou rmse (+. 1.0 cur-idx)]
                                           [best-idx best-iou best-rmse (+. 1.0 cur-idx)])
        (select{float |} (<. rmse best-rmse) [cur-idx iou rmse (+. 1.0 cur-idx)]
                                             [best-idx best-iou best-rmse (+. 1.0 cur-idx)])))
  (define first-box : [float 5] (head{float | boxes-num-1 [5]} box-pred))
  (define first-box-state [0.0
                           (yolo-box-iou first-box truth-box)
                           (yolo-box-rmse first-box truth-box)
                           0.0])
  (define rest-boxes (tail{float | boxes-num-1 [5]} box-pred))
  (define best-box-stats (fold{float [float 4] | boxes-num-1 [5] } box-cmp first-box-state rest-boxes))
  (define best-box-idx (float->int (index{float | [4] [] 1} best-box-stats [0])))

  (define (calc-box-delta [box [float 5]] [idx [int]])
     (select{float |} (= best-box-idx idx)
                      (best-yolo-box-delta box truth-box coord-scale obj-scale sqrt-flag rescore-flag)
                      (other-yolo-box-delta box noobj-scale)))
  (define delta-boxes (calc-box-delta box-pred iota{| [(+ 1 boxes-num-1)]}))
  (define dout (merge-box-and-class-delta{| (+ 1 classes-1) (+ 1 boxes-num-1)} delta-boxes class-delta))
  dout)

;; ---------------------------- ACTIVATIONS ---------------------------------------------

(define (leaky-relu [x [float]]) : float
  (select{float |} (>. x 0.0) x (*. 0.1 x)))

(define (leaky-relu-prime [x [float]]) : float
  (select{float |} (>. x 0.0) 1.0 0.1))

(define (linear [x [float]]) : float
  x)

(define (linear-prime [x [float]]) : float
  1.0)

(define (softmax{| in-1} [x [float (+ 1 in-1)]]) : [float (+ 1 in-1)]
  (let [e (exp x)]
    (/. e (reduce{float | in-1 [] []} +. e))))

; truth is one-hot encoding vector - there can only be 1 1.0 value, everything else is 0.0
; x is the output of softmax function
(define (softmax-prime{| in} [x [float in]] [truth [float in]]) : [float in]
  (-. x truth))

; turns softmax output vector to one-hot encoded vector -
; max value turns into 1, all others into 0
(define (softmax->class-vector{| in-1} [e [float (+ 1 in-1)]]): [float (+ 1 in-1)]
  (let [max-val (reduce{float | in-1 [] []} max2. e)]
    (if{float|} (=. e max-val) 1.0 0.0)))
    ;; ((fn ([v [float]] (select (=. v max-val) 1.0 0.0))) e)))


;; ---------------------------- FLATTEN (?) ---------------------------------------------
;; Flatten layers are to feed data into fully connected layers 
;; (since they require 1D input no matter what kind of data is pr;cessed)
(define (flatten-2d-fwd{| @in out} [input [float @in]]) : [float out]
  (reshape [out] input))

(define (flatten-2d-bwd{| @in out} [dy [float out]]) : [float @in]
  (reshape [@in] dy))



;; ---------------------------- TESTING ---------------------------------------------

;(flatten-2d-fwd{| [3 3 3 3] 81} (int->float iota{|[3 3 3 3]}))
; (subarray/2{int | 5 5 3 3} iota{| [5 5]} [0 0])
;; (define conv (conv-2d{| 2 1 2 1 0} (int->float iota{| [3 3]})
;;                      [[0.5 1.0] [1.5 2.0]]
;;                      1.0))

;; (define (batch-norm-2d{ | n-1 k}
;;                        [input [float k (+ 1 n-1) (+ 1 n-1)]]
;;                        [rolling-mean [float k]]
;;                        [rolling-var [float k]]
;;                        [bias [float k]]
;;                        [train [bool]])
;; (batch-norm-2d{| 1 1} (int->float iota{| [1 2 2]}) [0.0] [0.0] [1.3] #t)
;; (define (batch-norm-2d-back{| n-1 k}
;;                             [input [float k (+ 1 n-1) (+ 1 n-1)]]
;;                             [dout  [float k (+ 1 n-1) (+ 1 n-1)]]
;;                             [mean  [float k]]
;;                             [var   [float k]]
;;                             [rolling-mean [float k]]
;;                             [rolling-var  [float k]]
;;                             [train [bool]])
;; (batch-norm-2d-back{| 1 1} (int->float iota{| [1 2 2]})
;;                            (int->float iota{| [1 2 2]})
;;                            [1.5]
;;                            [1.667]
;;                            [0.0]
;;                            [0.0]
;;                            #t)

;; (define (max-pool-2d{| n-1 pool-size-1 out} [data [float (+ 1 n-1) (+ n-1 1)]]) : [float out out]

;; (define res (max-pool-2d{| 3 1 2 2} (int->float iota{| [4 4]})))
;; (define (max-pool-back{| in pool-size-1 out }
;;                           [in [float in in]]
;;                           [max-per-pool [float (+ pool-size-1 1) (+ pool-size-1 1)]]
;;                           [dout [float out out]]) ;: [float in in]
;;(max-pool-back{| 3 1 2 2} (int->float iota{| [4 4]}) res (int->float iota{| [2 2]}))

;; Precondition: boxes-arr-size = 5 * boxes-num
;; Precondition: n = boxes-arr-size + classes-1 + 1
;; (define (detection-2d{| n boxes-arr-size boxes-num-1 classes-1}
;;                       [input        [float n]]
;;                       [truth        [float n]]
;;                       [sqrt-flag    [bool]]
;;                       [rescore-flag [bool]]
;;                       [obj-scale    [float]]
;;                       [noobj-scale  [float]]
;;                       [coord-scale  [float]]
;;                       [class-scale  [float]])
;; (detection-2d{| 20 10 1 9 } (int->float iota{| [20]}) (int->float iota{| [20]}) #t #f 1.3 0.9 1.1 0.7)

;; (define (conv-2d{| n-1 k-1 o stride pad} [data [float (+ n-1 1) (+ n-1 1)]]
;;                               [weights [float (+ k-1 1) (+ k-1 1)]]
;;                               [bias [float]]) : [float o o]
;; (conv-2d{| 2 1 2 1 0} (int->float iota{| [3 3]})
;;        [[0.5 1.0] [1.5 2.0]]
;;        1.0)
;; one of the middle layers in YOLO, conv from 256 x 28 x 28 -> 512 x 26 x 26

;; (conv-2d-channel{| 27 2 31 26 1 0 }
;;   (int->float iota{| [64 32 28 28]})
;;   (int->float iota{| [64 32 3 3]})
;;   (replicate{float | [32] []} 1.0))
;; (transpose/4{int | 2 2 2 2 2 2 2 2} iota{| [2 2 2 2]} [0 2 1 3])
;; (define (flatten/4{t | in1 in2 in3 in4 out1 out2} [arr [t in1 in2 in3 in4]]) : [t out1 out2]
;; (flatten/4{int | 2 2 2 2 4 4} iota{| [2 2 2 2]})
;; (scatter{int |4 7 []} [3 5 7 9] [0 2 1 3])
;; (subarray-fill/2{int | 5 5 3 3} iota{| [5 5]} [-1 -1] 0)
;; (conv-2d{| 4 1 4 1 0 } (int->float iota{| [5 5]}) (int->float iota{| [2 2]}) [0.0])
;; (define (conv-2d-back{| n-1 k-1 o-1 pad stride} [data [float (+ 1 n-1) (+ 1 n-1)]]
;;                                                 [weights [float (+ 1 k-1) (+ 1 k-1)]]
;;                                                 [dout [float (+ 1 o-1) (+ 1 o-1)]])
;; (conv-2d-back{| 4 1 3 1 0} (int->float iota{| [5 5]})
;;                            (int->float iota{| [2 2]})
;;                            (int->float iota{| [4 4]}))

;; (define (conv-2d-back{| n-1 k-1 o-1 stride inner} [data [float (+ 1 n-1) (+ 1 n-1)]]
;;                                                   [weights [float (+ 1 k-1) (+ 1 k-1)]]
;;                                                   [dout [float (+ 1 o-1) (+ 1 o-1)]])
;; (define res (#1 (conv-2d-back{| 4 1 1 2 4 2 } (int->float iota{|[5 5]})
;;                            (int->float iota{|[3 3]})
;;                            (int->float iota{|[2 2]}))))
;; (unbox res (arr) arr)
;; (define (conv-2d-back-channel{| n-1 k-2 c-1 o-1 stride o*stride o_dil-1}
;;           [data [float (+ c-1 1) (+ n-1 1) (+ n-1 1)]]
;;           [weights [float (+ c-1 1) (+ k-1 1) (+ k-1 1)]]
;;           [dout [float (+ o-1 1) (+ o-1 1)]])
;; (define res (#0 (conv-2d-back-channel{|4 1 2 1 2 4 2}
;;                   (int->float iota{| [3 5 5]})
;;                   (int->float iota{| [3 3 3]})
;;                   (int->float iota{| [2 2]}))))
;; (unbox res (arr) arr)


;; ----------------------------------------- MAIN -------------------------------------------
;; This is going to be the YOLO-v1 tiny (because we don't free up memory yet)
;; Also, image size is halved
;; We don't do padding, just to save some memory with all allocation and such
;; bias in all convolution layers is 0 because we batch normalize instead
;; (define (batch-norm-2d{ | n-1 k}
;;                        [input [float k (+ 1 n-1) (+ 1 n-1)]]
;;                        [rolling-mean [float k]]
;;                        [rolling-var [float k]]
;;                        [bias [float k]]
;;                        [train [bool]])
;; (define (conv-2d-channel{| n-1 k-1 c-1 o stride pad}
;;           [data [float (+ c-1 1) (+ n-1 1) (+ n-1 1)]]
;;           [weights [float (+ c-1 1) (+ k-1 1) (+ k-1 1)]]
;;           [bias [float]]) : [float o o]
;; (define (max-pool-2d{| n-1 pool-size-1 stride out} [data [float (+ 1 n-1) (+ n-1 1)]]) ;: [float out out]

;; (define (fc-2d-fwd{| in-1 out-1} [input [float (+ in-1 1)]]
;;                                  [weights [float (+ out-1 1) (+ in-1 1)]]
;;                                  [bias [float (+ out-1 1)]]) : [float (+ out-1 1)]
;; This is for a single prediction cell, so
;; n = boxes-arr-size + classes-1 + 1 = (+ boxes-num-1 1) * 5 + classes-1 + 1
;; (define (detection-2d{| n boxes-arr-size boxes-num-1 classes-1}
;;                       [input        [float n]]
;;                       [truth        [float n]]
;;                       [sqrt-flag    [bool]]
;;                       [rescore-flag [bool]]
;;                       [obj-scale    [float]]
;;                       [noobj-scale  [float]]
;;                       [coord-scale  [float]]
;;                       [class-scale  [float]])



(define (full-conv-process{| out-ch in-ch-1 n-1 k-1 o-1 stride pad} [input [float (+ in-ch-1 1) (+ n-1 1) (+ n-1 1)]]) : [float out-ch (+ o-1 1) (+ o-1 1)]
  (define weights (int->float iota{| [out-ch (+ in-ch-1 1) (+ k-1 1) (+ k-1 1)]}))
  (define out_conv (conv-2d-channel{| n-1 k-1 in-ch-1 (+ 1 o-1) stride pad} input weights 0.0))
  (define out_norm_box (batch-norm-2d{| o-1 out-ch}
                           out_conv
                           (replicate{float | [out-ch] []} 0.0)
                           (replicate{float | [out-ch] []} 0.0)
                           (int->float iota{| [out-ch]})
                           #f))
  (define out_norm (unbox (#0 out_norm_box) (out) out))
  (define out (leaky-relu out_norm))
  out)

;; (detection-2d{| 30 10 1 19} (int->float iota{| [7 7 30]}) (int->float iota{| [30]}) #t #f 1.0 0.5 5.0 1.0)

(define input (int->float iota{| [3 448 448]}))
(define out1 (full-conv-process{| 192 2 447 6 220 2 0} input))
out1
;; (define out2 (max-pool-2d{| 220 1 2 110} out1))
;; (define out3 (full-conv-process{| 192 191 109 2 107 1 0} out2))
;; (define out4 (max-pool-2d{| 107 1 2 54} out3))
;; out4
;; (define out5 (full-conv-process{| 128 191 53 0 53 1 0} out4))
;; (define out6 (full-conv-process{| 256 127 53 2 51 1 0} out5))
;; (define out7 (full-conv-process{| 256 255 51 0 51 1 0} out6))
;; (define out8 (full-conv-process{| 512 255 51 2 49 1 0} out7))
;; (define out9 (max-pool-2d{| 49 1 2 24} out8))
;; out9
;; (define out10_1 (full-conv-process{| 256 511 23 0 23 1 0} out9))
;; (define out11_1 (full-conv-process{| 512 255 23 2 21 1 0} out10_1))
;; (define out10_2 (full-conv-process{| 256 511 21 0 21 1 0} out11_1))
;; (define out11_2 (full-conv-process{| 512 255 21 2 19 1 0} out10_2))
;; (define out10_3 (full-conv-process{| 256 511 19 0 19 1 0} out11_2))
;; (define out11_3 (full-conv-process{| 512 255 19 2 17 1 0} out10_3))
;; (define out10_4 (full-conv-process{| 256 511 17 0 17 1 0} out11_3))
;; (define out11   (full-conv-process{| 512 255 17 2 15 1 0} out10_4))
;; (define out12   (full-conv-process{| 512 511 15 0 15 1 0} out11))
;; (define out13   (full-conv-process{| 1024 511 15 2 13 1 0} out12))
;; out13
;; Skipping this layer cus no pad and the data becomes too small (define out14 max-pool)
;; (define out14 out13)
;; (define out15_1 (full-conv-process{| 512 1023 13 0 13 1 0} out14))
;; (define out16_1 (full-conv-process{| 1024 511 13 2 11 1 0} out15_1))
;; (define out15_2 (full-conv-process{| 512 1023 11 0 11 1 0} out16_1))
;; (define out16   (full-conv-process{| 1024 511 11 2 9 1 0} out15_2))
;; (define out17   (full-conv-process{| 1024 1023 9 2 7 1 0} out16))
;; next three layers are skipped cause not enough data before connected layer
;; stride has to be 2 here, but we don't have enough data to do this
;; (define out18   (full-conv-process{| 1024 1024 9 2 7 2 0} out18))
;; (define out18 out17)
;; (define out19 out18)
;; (define out20 out19)
;; (define w21 (int->float iota{| [4096 65536]}))
;; (define b21 (replicate{float | [4096] []} 0.0))
;; (define in21 (reshape [65536] out20))
;; (define out21_conn (fc-2d-fwd{| 65535 4095} in21 w21 b21))
;; (define out21 (linear out21_conn))
;; (define w22 (int->float iota{| [1470 4096]}))
;; (define b22 (replicate{float | [1470] []} 0.0))
;; (define out22_conn (fc-2d-fwd{| 4095 1469} out21 w22 b22))
;; (define out22 (linear out22_conn)) 
;; (define in-res (reshape [7 7 30] out22))
;; (define truth (int->float iota{| [30]}))
;; (define result (detection-2d{| 30 10 1 19} in-res truth #t #f 1.0 0.5 5.0 1.0))
;; result

;; Layer 1
;; (define w1 (int->float iota{| [192 3 7 7]}))
;; (define out1_conv (conv-2d-channel{| 223 6 2 109 2 0} input w1 0.0))
;; (define out1_norm_box (batch-norm-2d{| 108 192}
;;                          out1_conv
;;                          (replicate{float | [192] []} 0.0)
;;                          (replicate{float | [192] []} 0.0)
;;                          (int->float iota{| [192]})
;;                          #f))
;; (define out1_norm (unbox (#0 out1_norm_box) (out) out))
;; (define out1 (leaky-relu out1_norm))
;; ;; Layer 2
;; (define out2 (max-pool-2d{| 108 1 2 54} out1))
;;  ;; Layer 3
;; (define w3 (int->float iota{| [128 192 3 3]}))
;; (define out3_conv (conv-2d-channel{| 53 2 191 52 1 0} out2 w3 0.0))
;; (define out3_norm_box (batch-norm-2d{| 51 128}
;;                          out3_conv
;;                          (replicate{float | [128] []} 0.0)
;;                          (replicate{float | [128] []} 0.0)
;;                          (int->float iota{| [128]})
;;                          #t))
;; (define out3_norm (unbox (#0 out3_norm_box) (out) out))
;; (define out3 (leaky-relu out3_norm))
;; ;; Layer 4
;; ;; a bunch of data is lost here because we don't do padding and # of elts is odd
;; (define out4 (max-pool-2d{| 51 1 2 26} out3))
;; ;; Layer 5
;; (define w5 (int->float iota{| [256 128 1 1]}))
;; (define out5_conv (conv-2d-channel{| 25 0 127 24 1 0} out4 w5 0.0))
;; (define out5_norm_box (batch-norm-2d{| 23 256}
;;                          out5_conv
;;                          (replicate{float | [256] []} 0.0)
;;                          (replicate{float | [256] []} 0.0)
;;                          (int->float iota{| [256]})
;;                          #f))
;; (define out5_norm (unbox (#0 out5_norm_box) (out) out))
;; (define out5 (leaky-relu out5_norm))

;; ;; Layer 6
;; ;; c 3x3x256
;; (define w6 (int->float iota{| [256 256 3 3]}))
;; (define out6_conv (conv-2d-channel{|} out5 w6 0.0))
;; (define out6_norm_box (batch-norm-2d{|}
;;                          out6_conv
;;                          (replicate{float | [256] []} 0.0)
;;                          (replicate{float | [256] []} 0.0)
;;                          (int->float iota{| [256]})
;;                          #f))
;; (define out6_norm (unbox (#0 out6_norm_box) (out) out))
;; (define out6 (leaky-relu out6_norm))

;; ;; Layer 7
;; ;; c 1x1x256
;; (define w7 (int->float iota{| [512 256 1 1]}))
;; (define out7_conv (conv-2d-channel{|} out6 w6 0.0))
;; (define out7_norm_box (batch-norm-2d{|}
;;                          out7_conv
;;                          (replicate{float | [512] []} 0.0)
;;                          (replicate{float | [512] []} 0.0)
;;                          (int->float iota{| [512]})
;;                          #f))
;; (define out7_norm (unbox (#0 out7_norm_box) (out) out))
;; (define out7 (leaky-relu out7_norm))
;; ;; Layer 8
;; ;; c 3x3x512
;; (define w8 (int->float iota{| [256 512 3 3]}))
;; (define out8_conv (conv-2d-channel{|} out7 w6 0.0))
;; (define out8_norm_box (batch-norm-2d{|}
;;                          out8_conv
;;                          (replicate{float | [256] []} 0.0)
;;                          (replicate{float | [256] []} 0.0)
;;                          (int->float iota{| [256]})
;;                          #f))
;; (define out8_norm (unbox (#0 out8_norm_box) (out) out))
;; (define out8 (leaky-relu out8_norm))
;; ;; Layer 9
;; ;; pool 2x2
;; (define out9 (max-pool-2d{|} out8))
;; ;; Layer 10, 11 x 4 c
;; ;; 1x1x256
;; ;; 3x3x512
;; ;; ^ x 4
;; (define w10_1 (int->float iota{| [256 512 3 3]}))
;; (define out10_1_conv (conv-2d-channel{|} out7 w6 0.0))
;; (define out10_1_norm_box (batch-norm-2d{|}
;;                          out8_conv
;;                          (replicate{float | [256] []} 0.0)
;;                          (replicate{float | [256] []} 0.0)
;;                          (int->float iota{| [256]})
;;                          #f))
;; (define out10_1_norm (unbox (#0 out8_norm_box) (out) out))
;; (define out10_1 (leaky-relu out8_norm))
;; (define w11_1 (int->float iota{| [256 512 3 3]}))
;; (define out11_1_conv (conv-2d-channel{|} out7 w6 0.0))
;; (define out11_1_norm_box (batch-norm-2d{|}
;;                          out8_conv
;;                          (replicate{float | [256] []} 0.0)
;;                          (replicate{float | [256] []} 0.0)
;;                          (int->float iota{| [256]})
;;                          #f))
;; (define out11_1_norm (unbox (#0 out8_norm_box) (out) out))
;; (define out11_1 (leaky-relu out8_norm))
;; (define w10_2 (int->float iota{| [256 512 3 3]}))
;; (define out10_2_conv (conv-2d-channel{|} out7 w6 0.0))
;; (define out10_2_norm_box (batch-norm-2d{|}
;;                          out8_conv
;;                          (replicate{float | [256] []} 0.0)
;;                          (replicate{float | [256] []} 0.0)
;;                          (int->float iota{| [256]})
;;                          #f))
;; (define out10_2_norm (unbox (#0 out8_norm_box) (out) out))
;; (define out10_2 (leaky-relu out8_norm))
;; (define w11_2 (int->float iota{| [256 512 3 3]}))
;; (define out11_2_conv (conv-2d-channel{|} out7 w6 0.0))
;; (define out11_2_norm_box (batch-norm-2d{|}
;;                          out8_conv
;;                          (replicate{float | [256] []} 0.0)
;;                          (replicate{float | [256] []} 0.0)
;;                          (int->float iota{| [256]})
;;                          #f))
;; (define out11_2_norm (unbox (#0 out8_norm_box) (out) out))
;; (define out11_2 (leaky-relu out8_norm))
;; (define w10_3 (int->float iota{| [256 512 3 3]}))
;; (define out10_3_conv (conv-2d-channel{|} out7 w6 0.0))
;; (define out10_3_norm_box (batch-norm-2d{|}
;;                          out8_conv
;;                          (replicate{float | [256] []} 0.0)
;;                          (replicate{float | [256] []} 0.0)
;;                          (int->float iota{| [256]})
;;                          #f))
;; (define out10_3_norm (unbox (#0 out8_norm_box) (out) out))
;; (define out10_3 (leaky-relu out8_norm))
;; (define w11_3 (int->float iota{| [256 512 3 3]}))
;; (define out11_3_conv (conv-2d-channel{|} out7 w6 0.0))
;; (define out11_3_norm_box (batch-norm-2d{|}
;;                          out8_conv
;;                          (replicate{float | [256] []} 0.0)
;;                          (replicate{float | [256] []} 0.0)
;;                          (int->float iota{| [256]})
;;                          #f))
;; (define out11_3_norm (unbox (#0 out8_norm_box) (out) out))
;; (define out11_3 (leaky-relu out8_norm))
;; (define w10_4 (int->float iota{| [256 512 3 3]}))
;; (define out10_4_conv (conv-2d-channel{|} out7 w6 0.0))
;; (define out10_4_norm_box (batch-norm-2d{|}
;;                          out8_conv
;;                          (replicate{float | [256] []} 0.0)
;;                          (replicate{float | [256] []} 0.0)
;;                          (int->float iota{| [256]})
;;                          #f))
;; (define out10_4_norm (unbox (#0 out8_norm_box) (out) out))
;; (define out10_4 (leaky-relu out8_norm))
;; (define w11_4 (int->float iota{| [256 512 3 3]}))
;; (define out11_4_conv (conv-2d-channel{|} out7 w6 0.0))
;; (define out11_4_norm_box (batch-norm-2d{|}
;;                          out8_conv
;;                          (replicate{float | [256] []} 0.0)
;;                          (replicate{float | [256] []} 0.0)
;;                          (int->float iota{| [256]})
;;                          #f))
;; (define out11_4_norm (unbox (#0 out8_norm_box) (out) out))
;; (define out11_4 (leaky-relu out8_norm))
;; ;; Layer 12
;; ;; c 1x1x512
;; ;; Layer 13
;; ;; c 3x3x1024
;; ;; Layer 14
;; ;; pool 2x2
;; (define out14 (max-pool-2d{|} out13))
;; ;; Layer 15,16 x 2 c
;; ;; 1x1x512
;; ;; 3x3x1024
;; ;; ^ x 2
;; ;; Layer 17
;; ;; c 3x3x1024
;; ;; Layer 18
;; ;; c 3x3x1024 stride=2 (?)
;; ;; Layer 19
;; ;; c 3x3x1024
;; ;; Layer 20
;; ;; c 3x3x1024
;; ;; Layer 21
;; ;; fc 50176x4096
;; ;; Layer 22
;; ;; fc 4096x1470
;; ;; 23 detection
